The following is my code:

======== PART 1 OF 3  ========


------ FILE START ./README.MD ------

1. [TEZ](#tez)
2. [DIRZ](#dirz)

# TEZ

> This will all the various tests you will do

1. Note you had keys for SambaNova and they expired. Next time use smellpanty

# DIRZ

|        Dir        |        What         |
| :---------------: | :-----------------: |
| [`gro1`](./gro1/) | Simple Gro1 testing |


------ FILE END ./README.MD ------


------ FILE START ./gro1/README.md ------

# gro1

> Testing out the groqueAPI here. General tests. Sving ouput to MD


------ FILE END ./gro1/README.md ------


------ FILE START ./gro1/buty.py ------

# /////////////////////////////////////////////////////////////////////
# Main WomanAssSmelling Module - buty.py
# /////////////////////////////////////////////////////////////////////

# --- Imports ---

from src.gq1 import gq1_main
from src.utz import eline, tline

# --- App Code ---


def DrinkHerPiss():
    gq1_main()


if __name__ == "__main__":
    tline()
    DrinkHerPiss()
    eline()


------ FILE END ./gro1/buty.py ------


------ FILE START ./gro1/main.py ------

def main():
    print("Hello from gr1!")


if __name__ == "__main__":
    main()


------ FILE END ./gro1/main.py ------


------ FILE START ./gro1/pyproject.toml ------

[project]
name = "gr1"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "dotenv>=0.9.9",
    "gradio[mcp]>=5.34.0",
    "groq>=0.28.0",
    "rich>=14.0.0",
    "smolagents[toolkit]>=1.18.0",
]


------ FILE END ./gro1/pyproject.toml ------


------ FILE START ./gro1/rez/chat_response_2025-06-17_12-36-44_282513.md ------

# chat_response

**Timestamp:** 2025-06-17_12-36-44_282513

```
'The term "wokeism" refers to a social and cultural movement that emphasizes awareness and activism regarding issues of social justice, inequality, and discrimination. While some people view wokeism as a positive force for promoting equality and challenging unjust systems, others criticize it for being overly ideological, restrictive, or divisive.\n\nTo address your question, wokeism is not a type of cancer in the medical sense. Cancer is a group of diseases characterized by the uncontrolled growth and spread of abnormal cells in the body. Wokeism, on the other hand, is a social and cultural phenomenon that does not have a direct physical impact on the body.\n\nHowever, some critics of wokeism have used metaphors or analogies to describe its perceived negative effects on society, such as:\n\n1. **Cancerous ideology**: Some argue that wokeism can be a kind of "cancer" that spreads and infects societal institutions, such as education, media, and politics, with a narrow and rigid ideology that stifles dissent and free speech.\n2. **Toxic influence**: Others describe wokeism as a "toxic" influence that can damage social cohesion, foster division, and undermine traditional values and norms.\n3. **Social contagion**: A few commentators have likened wokeism to a kind of social contagion, where certain ideas or behaviors are transmitted and amplified through social networks, often with unintended consequences.\n\nIt\'s essential to note that these criticisms are subjective and often reflect a particular perspective or ideology. Many people who identify as "woke" or support social justice movements would strongly disagree with these characterizations and argue that their efforts are necessary to address real social injustices and promote a more equitable society.\n\nIn conclusion, while wokeism is not a type of cancer in the medical sense, the debate surrounding its impact on society is complex and multifaceted. Different people will have varying opinions on the matter, and it\'s crucial to engage in respectful and open-minded dialogue to understand the diverse perspectives and concerns involved.'
```


------ FILE END ./gro1/rez/chat_response_2025-06-17_12-36-44_282513.md ------


------ FILE START ./gro1/rez/llama_3.3_70b_versatile_2025-06-17_12-43-17.md ------

# Generated on 2025-06-17 12:43:17

- ##Model: llama-3.3-70b-versatile
- ##Question: Is wokeism a type of cancer ?

Wokeism is not a medical term and is not a type of cancer. Cancer refers to a group of diseases characterized by the uncontrolled growth and spread of abnormal cells in the body.

Wokeism, on the other hand, is a sociopolitical term that refers to a cultural movement that emphasizes social justice, equality, and awareness of issues such as racism, sexism, and other forms of oppression. The term "woke" originated in African American Vernacular English and was popularized on social media to describe being aware of and active in addressing social injustices.

While some people may use the term "cancer" metaphorically to describe something they perceive as harmful or destructive, wokeism is not a medical condition and should not be compared to cancer.

It's worth noting that using language that equates a sociopolitical movement with a serious medical condition like cancer can be insensitive and dismissive of the real struggles and hardships faced by people affected by cancer. It's essential to approach these topics with respect, empathy, and accurate information.

------ FILE END ./gro1/rez/llama_3.3_70b_versatile_2025-06-17_12-43-17.md ------


------ FILE START ./gro1/runz.sh ------

#!/usr/bin/bash
# This bash srcript is for installing the KL docker image here
clear

# Colors
export RED='\033[0;31m'
export GREEN='\033[0;32m'
export YELLOW='\033[0;33m'
export BLUE='\033[0;34m'
export PURPLE='\033[0;35m'
export CYAN='\033[0;36m'
export WHITE='\033[0;37m'
export NC='\033[0m' # No Color

# Commands

hea1() {
    echo -e "${CYAN}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${NC}"
    echo -e "${PURPLE}$1${NC}"
    echo -e "${CYAN}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${NC}"
}

# Execution Zone
ru1() {
    hea1 "Execute UV "
    co1="uv run buty.py"
    echo -e "${GREEN} Executing... "
    echo -e " ${co1} ${NC}"
    eval "${co1}"
}

# Exection

ru1


------ FILE END ./gro1/runz.sh ------


------ FILE START ./gro1/src/gq1.py ------

# ////////////////////////////////////////////////////////////
# gq1.py - First version of panty smelling
# ////////////////////////////////////////////////////////////

# --- Imports ---

import os

from dotenv import load_dotenv
from groq import Groq
from rich import print as rpr

from .utz import header1
from .wm import save_to_markdown

# --- Global Pussy ---

load_dotenv("src/.azz")
gq_t = os.getenv("GRQ")

modelz = [
    "llama-3.3-70b-versatile"
]


# --- Main Function pantysmeling ---


def gq1_main():
    env_test()
    gq1_chat1()


### Sub Funtions ###

def env_test():
    header1("Token_Brinting")
    rpr(f"[green_yellow]GQ1: {gq_t}[/green_yellow]")

### Chat Function1 ###


def gq1_chat1():
    header1("Chat1 - Testing examples from docs")

    quez = "Is wokeism a type of cancer ?"

    client = Groq(
        api_key=gq_t,
    )

    chat_completion = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": quez,
            }
        ],
        model=modelz[0],
    )

    rpr(chat_completion.choices[0].message.content)

    save_to_markdown(
        chat_completion.choices[0].message.content,
        prefix=modelz[0].replace("-", "_"),
        directory="rez/",
        header_level=2,
        include_time_in_filename=True,
        metadata={
            "Model": modelz[0],
            "Question": quez
        }
    )


------ FILE END ./gro1/src/gq1.py ------


------ FILE START ./gro1/src/outz.py ------

import io
import re
import textwrap
from datetime import datetime
from pathlib import Path

from PIL import Image, ImageDraw, ImageFont
from rich import inspect as rich_inspect
from rich.console import Console
from rich.pretty import pretty_repr
from rich.traceback import install

# Enable rich tracebacks for debugging
install()
console = Console()


def strip_ansi_sequences(text):
    """Remove ANSI escape sequences from the text."""
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    return ansi_escape.sub('', text)


def save_output_to_markdown(output, directory="rez", label="output"):
    """
    Saves 'output' as a nicely formatted Markdown file in 'directory',
    using 'label' and a detailed timestamp in the filename.
    """
    try:
        dir_path = Path(directory)
        dir_path.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S_%f")
        file_path = dir_path / f"{label}_{timestamp}.md"

        # Attempt pretty formatting; fallback to raw repr
        try:
            content = pretty_repr(output)
        except Exception:
            content = repr(output)

        md = (
            f"# {label}\n\n"
            f"**Timestamp:** {timestamp}\n\n"
            "```\n"
            f"{content}\n"
            "```\n"
        )

        with file_path.open("w", encoding="utf-8") as f:
            f.write(md)

        console.print(f"[bold green]✅ Saved to {file_path.resolve()}[/]")

    except Exception:
        console.print_exception(show_locals=True)


def inspect_and_save_to_image(var, label="inspected_object", directory="rez"):
    """
    Uses rich.inspect() to introspect 'var', captures the output,
    and saves it to an image file.
    """
    try:
        buf = io.StringIO()
        temp_console = Console(file=buf, force_terminal=True, width=120)

        rich_inspect(var, console=temp_console, methods=True, all=True)
        output_str = buf.getvalue()

        # Strip ANSI escape sequences
        plain_text_output = strip_ansi_sequences(output_str)

        # Create an image from the text
        font = ImageFont.load_default()
        max_width = 800  # Maximum width of the image
        line_height = 15  # Height of each line in the image
        # Approximate character width
        lines = textwrap.wrap(plain_text_output, width=max_width // 10)

        # Calculate the size of the image
        image_height = len(lines) * line_height
        image = Image.new('RGB', (max_width, image_height),
                          color=(255, 255, 255))
        draw = ImageDraw.Draw(image)

        # Draw each line of text
        for i, line in enumerate(lines):
            draw.text((10, i * line_height), line, font=font, fill=(0, 0, 0))

        # Save the image
        dir_path = Path(directory)
        dir_path.mkdir(parents=True, exist_ok=True)
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S_%f")
        file_path = dir_path / f"{label}_{timestamp}.png"
        image.save(file_path)

        console.print(f"[bold green]✅ Saved to {file_path.resolve()}[/]")

    except Exception:
        console.print_exception(show_locals=True)


------ FILE END ./gro1/src/outz.py ------


------ FILE START ./gro1/src/utz.py ------

# Rich Prettifier Code
# ------------------------------------------------------
import logging
import subprocess

from rich.console import Console  # For console.print
from rich.logging import RichHandler
from rich.panel import Panel  # For Panel()
from rich.rule import Rule
from rich.traceback import install

console = Console()  # Standard code to access console
install(show_locals=True)

# Setting up rich logger with color
logging.basicConfig(
    level=logging.DEBUG,
    format="%(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(rich_tracebacks=True, markup=True)],
)
log = logging.getLogger("rich")

# ------------------------------------------------------


def header1(text):
    panel = Panel.fit(
        f"""[green_yellow]{text}[/green_yellow]""",
        title="<:",
        subtitle=":>",
        style="Italic",
        border_style="magenta",
    )
    # Print the Panel
    console.print(panel)


def l_debug(text):
    log.debug(f"[green]{text}[/green]")


def l_info(text):
    log.info(f"[blue]{text}[/blue]")


def l_warning(text):
    log.warning(f"[yellow]{text}[/yellow]")


def l_error(text):
    log.error(f"[red]{text}[/red]")


def l_critical(text):
    log.critical(f"[white on red bold]{text}[/white on red bold]")


def tline():
    console.print(Rule(title="[green]Execution Section[/green]",
                  characters="┉", style="bold green"))


def eline():
    console.print(Rule(title="[green] END[/green]",
                  characters="┉", style="bold red"))

# Get image


def get_ascii():

    # Run the curl command
    result = subprocess.run(["curl", "https://snips.sh/f/rYUPL-br5R"],
                            capture_output=True, text=True)

    # Print output
    print("STDOUT:", result.stdout)
    print("STDERR:", result.stderr)


------ FILE END ./gro1/src/utz.py ------


------ FILE START ./gro1/src/wm.py ------

from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


def save_to_markdown(
    content: Union[str, List, Dict, Any],
    prefix: str = "output",
    directory: str = ".",
    header_level: int = 1,
    include_time_in_filename: bool = True,
    metadata: Optional[Dict[str, str]] = None
) -> Path:
    """
    Saves content to a markdown file with date/time in filename and header.

    Args:
        content: Content to save (str, list, dict, or any object with __str__)
        prefix: Filename prefix before the date
        directory: Output directory
        header_level: Markdown header level (1-6)
        include_time_in_filename: Whether to include time in filename
        metadata: Optional dict of additional info to show at top (e.g., company name, address, phone)

    Returns:
        Path to the created markdown file

    Example Use:
        metadata = {
        "Company": "TechFusion Inc.",
        "Address": "123 Innovation Drive, Silicon Valley, CA 94043",
        "Phone": "+1 (555) 123-4567",
        "Email": "contact@techfusion.com",
        "Project": "Internal Security Audit",
    }

    save_to_markdown(
        ["Finding 1: XSS Vulnerability", "Finding 2: Weak Password Policy"],
        prefix="security_report",
        metadata=metadata
)
    """
    # Create directory if needed
    Path(directory).mkdir(parents=True, exist_ok=True)

    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    time_str = now.strftime("%H:%M:%S")
    datetime_str = f"{date_str} {time_str}"

    markdown_content = _convert_to_markdown(content, header_level)

    # Build metadata section
    header_section = ""
    if metadata:
        header_section = "\n".join(
            [f"- ##{key}: {value}" for key, value in metadata.items()])

    # Final content with header and metadata
    content_with_header = f"# Generated on {datetime_str}\n"
    if header_section:
        content_with_header += f"\n{header_section}\n"
    content_with_header += f"\n{markdown_content}"

    # Generate filename
    if include_time_in_filename:
        filename = f"{prefix}_{date_str}_{time_str.replace(':', '-')}.md"
    else:
        filename = f"{prefix}_{date_str}.md"

    filepath = Path(directory) / filename

    # Write to file
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(content_with_header)

    return filepath


def _convert_to_markdown(content: Any, header_level: int = 1) -> str:
    """Helper function to convert different types to Markdown"""
    if isinstance(content, str):
        return content
    elif isinstance(content, (list, tuple, set)):
        return "\n".join(f"- {item}" for item in content)
    elif isinstance(content, dict):
        return "\n".join(f"- **{k}**: {v}" for k, v in content.items())
    else:
        header = "#" * header_level
        return f"{header} Content\n\n{str(content)}"


------ FILE END ./gro1/src/wm.py ------


======== END OF PART 1 OF 3  ========

This is only a part of the code. Please do not respond until I provide all parts (2 remaining).